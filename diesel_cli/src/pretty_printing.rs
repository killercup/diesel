use std::fmt::{Write, Error as FmtError};

/// Simple pretty printer hand tailored for the output generated by the `quote`
/// crate for schema inference.
///
/// # Rules
///
/// 1. Seeing `{` increases indentation level
/// 2. Seeing `}` decreases indentation level
/// 3. Insert newline after `{`, `}`, `,`, and `;`
/// 4. Don't put spaces:
///   - between ident and `!`,
///   - between path segments and `::`
///   - after `(`, '<' and before `)`, `>`
///   - before `,`
pub fn format_schema(schema: &str) -> Result<String, FmtError> {
    let mut out = String::with_capacity(schema.len());
    let mut indent = String::new();
    let mut skip_space = false;
    let mut last_char = ' ';

    for c in schema.chars() {
        // The `quote!` macro inserts whitespaces at some strange location,
        // let's remove them!
        match c {
            '!' | '(' | ';' | ',' | '<' | ')' | '>' if last_char.is_whitespace() => {
                out.pop();
            },
            ':' if last_char.is_whitespace() => {
                // Unless we are at the beginning of a fully qualified path,
                // remove the whitespace.
                let char_before_whitespace = {
                    let mut chars = out.chars();
                    chars.next_back();
                    chars.next_back()
                };

                if char_before_whitespace != Some('>') {
                    out.pop();
                }
            },
            _=> { }
        }

        if skip_space && c.is_whitespace() && last_char != '>' {
            continue;
        }

        last_char = c;
        skip_space = false;

        // At this point, there is an empty line before `}`. We need to remove
        // the already inserted indent, because the new indent is smaller than
        // the old one.
        if c == '}' {
            while let Some(c) = out.pop() {
                if c == '\n' {
                    break;
                }
            }

            indent.pop();
            write!(out, "\n{}", indent)?;
        }

        write!(out, "{}", c)?;

        // We need to insert newlines in some places and adjust the indent.
        // Also, we need to remember if we could skip the next whitespace.
        match c {
            ';' | ',' | '}' => {
                skip_space = true;
                write!(out, "\n{}", indent)?;
            },
            '{' => {
                skip_space = true;
                indent += "\t";
                write!(out, "\n{}", indent)?;
            },
            ':' | '(' | '<' => skip_space = true,
            _=>{}
        }
    }

    Ok(out.replace("\t", "    "))
}


#[cfg(test)]
mod tests {
    use super::format_schema;

    fn run_test(input: &str, expected: &str){
        let actual = format_schema(input).unwrap();
        assert_eq!(expected, actual);
    }

    #[test]
    fn test_remove_whitespace_colon() {
        run_test(":: diesel :: types :: Text", "::diesel::types::Text");
    }

    #[test]
    fn test_format_nullable() {
        run_test("Nullable < :: diesel :: types :: Text >",
            "Nullable<::diesel::types::Text>");
    }

        #[test]
    fn test_format_nullable_multispace() {
        run_test("Nullable <  Integer >",
            "Nullable<Integer>");
    }

    #[test]
    fn test_newline_after_comma() {
        run_test(",", ",\n");
    }

    #[test]
    fn test_increase_indent() {
        run_test("{","{\n    ");
    }

    #[test]
    fn test_decrease_indent() {
        run_test("{abc,}","{\n    abc,\n}\n");
    }

    #[test]
    fn test_format_arrow() {
        run_test("created_at -> :: diesel :: types :: Timestamp",
            "created_at -> ::diesel::types::Timestamp");
    }

    #[test]
    fn test_format_full_line() {
        run_test("created_at -> :: diesel :: types :: Timestamp ,",
            "created_at -> ::diesel::types::Timestamp,\n");
    }

    #[test]
    fn test_format_include_line() {
        run_test("pub use self :: infer_locks :: * ;",
            "pub use self::infer_locks::*;\n");
    }

    #[test]
    fn test_format_generated_mod() {
        run_test("mod infer_users { table ! { users ( id ) { id -> :: diesel :: types :: Int4 , username -> :: diesel :: types :: Varchar , password -> :: diesel :: types :: Varchar , } } } pub use self :: infer_users :: * ;",
r"mod infer_users {
    table! {
        users(id) {
            id -> ::diesel::types::Int4,
            username -> ::diesel::types::Varchar,
            password -> ::diesel::types::Varchar,
        }
    }
}
pub use self::infer_users::*;
");
    }
}
